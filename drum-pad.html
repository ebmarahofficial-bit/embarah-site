<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Ebmarah ‚Äì Drum Pad (Press & Hold Loops)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" type="image/png" href="assets/favicon.png" />
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700&display=swap');

    :root{
      --neon:#00ff99; --ink:#e0ffe8; --bg:#020d07; --card:#06140f; --line:#0d2a1f;
    }
    *{ box-sizing:border-box }
    html,body{ height:100% }
    body{
      margin:0; font-family:'Orbitron',sans-serif; color:var(--ink);
      background: radial-gradient(1200px 1200px at 50% -10%, rgba(0,255,153,.07), transparent 40%) , #000;
      min-height:100%;
      -webkit-tap-highlight-color: transparent;
    }
    .wrap{
      max-width:1100px; margin:0 auto; padding:16px 16px 64px;
    }
    header{
      display:flex; align-items:center; justify-content:space-between; gap:12px;
      padding:10px 0 18px; border-bottom:1px solid var(--line);
    }
    .brand{
      display:flex; align-items:center; gap:10px; font-weight:700;
      letter-spacing:.5px; color:var(--neon);
    }
    .brand .dot{ width:10px; height:10px; border-radius:50%; background:var(--neon); box-shadow:0 0 12px var(--neon) }
    #status{ font-size:.95rem; opacity:.9 }
    .controls{
      display:flex; flex-wrap:wrap; gap:10px; align-items:center;
    }
    button, .slider{
      font:inherit; color:var(--ink); background:var(--card);
      border:1px solid var(--line); border-radius:10px; padding:10px 14px; cursor:pointer;
    }
    button[disabled]{ opacity:.5; cursor:not-allowed }
    .slider{ padding:10px }
    .slider input{ width:160px }
    .grid{
      display:grid; grid-template-columns:repeat(5,minmax(120px,1fr)); gap:12px; margin-top:16px;
    }
    @media (max-width:820px){
      .grid{ grid-template-columns:repeat(3,minmax(100px,1fr)) }
    }
    @media (max-width:520px){
      .grid{ grid-template-columns:repeat(2,minmax(120px,1fr)) }
    }
    .pad{
      position:relative;
      background:linear-gradient(180deg, rgba(0,255,153,.08), rgba(0,0,0,.4));
      border:1px solid var(--line); border-radius:16px;
      aspect-ratio:1/1; display:grid; place-items:center;
      text-align:center; user-select:none; touch-action: none;
      transition: transform .04s ease, box-shadow .14s ease, border-color .14s ease;
      box-shadow: inset 0 0 0 1px rgba(0,255,153,.08);
    }
    .pad:active{ transform: scale(.98) }
    .pad.playing{
      border-color: var(--neon);
      box-shadow: 0 0 20px rgba(0,255,153,.25), inset 0 0 0 1px rgba(0,255,153,.25);
    }
    .label{ font-size:1.05rem; line-height:1.2 }
    .keyhint{ position:absolute; top:8px; right:10px; font-size:.8rem; opacity:.65 }
    footer{ margin-top:18px; font-size:.9rem; opacity:.85 }
    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center }
    .pill{ border:1px solid var(--line); background:var(--card); padding:8px 12px; border-radius:999px }
    .mb8{ margin-bottom:8px }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="brand"><span class="dot"></span> Ebmarah Drum Pad</div>
      <div id="status">tap ‚ÄúUnlock Audio‚Äù first (browser policy)</div>
    </header>

    <section class="mb8">
      <div class="controls">
        <button id="unlock">üîì Unlock Audio</button>
        <span class="pill">Loop transport:</span>
        <button id="playLoop" disabled>‚ñ∂Ô∏è Play Loop</button>
        <button id="stopLoop" disabled>‚èπ Stop Loop</button>
        <label class="slider">Loop Vol
          <input id="loopVol" type="range" min="0" max="1" step="0.01" value="1" disabled />
        </label>
      </div>
      <div style="margin-top:6px; font-size:.9rem; opacity:.8">
        Tip: hold a pad to sustain its loop; release to stop. Keys 1-0 also trigger pads.
      </div>
    </section>

    <section>
      <div id="padGrid" class="grid" role="group" aria-label="Drum pads"></div>
    </section>

    <footer>
      <div>Rules for fan samples: keep it fun (no slurs, hate, politics, or threats). Short phrases welcome like ‚Äúebmarah you a‚Ä¶(be creative)‚Äù‚Äîclean or bleep-able üòâ</div>
    </footer>
  </div>

  <!-- Drum pad logic (press-and-hold smooth loop) -->
  <script>
  (() => {
    // ===== Paths (adjust to your structure) =====
    // Backing loop (100% volume by default; slider controls it)
    const DRUM_LOOP = 'assets/audio/loops/eb_loop_140.mp3';
    // Ten pad samples (mp3). File names can be whatever; just match the ids below.
    const SAMPLES = [
      { id: 'bass1',  label: 'Bass 1',  key: '1' },
      { id: 'bass2',  label: 'Bass 2',  key: '2' },
      { id: 'bass3',  label: 'Bass 3',  key: '3' },
      { id: 'bass4',  label: 'Bass 4',  key: '4' },
      { id: 'bass5',  label: 'Bass 5',  key: '5' },
      { id: 'bass6',  label: 'Bass 6',  key: '6' },
      { id: 'bass7',  label: 'Bass 7',  key: '7' },
      { id: 'bass8',  label: 'Bass 8',  key: '8' },
      { id: 'bass9',  label: 'Bass 9',  key: '9' },
      { id: 'bass10', label: 'Bass 10', key: '0' },
    ];
    const SAMPLE_BASE = 'assets/audio/pads/';

    // ===== DOM =====
    const statusEl = document.getElementById('status');
    const unlockBtn = document.getElementById('unlock');
    const playBtn = document.getElementById('playLoop');
    const stopBtn = document.getElementById('stopLoop');
    const loopVol = document.getElementById('loopVol');
    const grid = document.getElementById('padGrid');

    // ===== Build pads =====
    const frag = document.createDocumentFragment();
    SAMPLES.forEach(s => {
      const btn = document.createElement('button');
      btn.className = 'pad kb';
      btn.dataset.id = s.id;
      btn.dataset.key = s.key;
      btn.setAttribute('aria-label', s.label);
      btn.innerHTML = `<div class="keyhint">${s.key}</div><div class="label">${s.label}</div>`;
      // Press & hold looping
      btn.addEventListener('pointerdown', (e) => { e.preventDefault(); startHoldLoop(s.id, btn, e); });
      btn.addEventListener('pointerup',   () => stopHoldLoop(btn));
      btn.addEventListener('pointercancel',() => stopHoldLoop(btn));
      btn.addEventListener('pointerleave',() => stopHoldLoop(btn));
      btn.addEventListener('contextmenu', e => e.preventDefault());
      frag.appendChild(btn);
    });
    grid.appendChild(frag);

    // Map keys to buttons after nodes exist
    const keyToBtn = new Map();
    function mapKeys() {
      document.querySelectorAll('.pad').forEach(b => keyToBtn.set(b.dataset.key, b));
    }

    // ===== Web Audio =====
    let ctx = null, loopGain = null, loopSource = null, loopBuffer = null;
    const padBuffers = new Map();

    unlockBtn.addEventListener('click', async () => {
      try {
        if (!ctx) ctx = new (window.AudioContext || window.webkitAudioContext)({ latencyHint: 'interactive' });
        status('loading audio‚Ä¶');

        loopGain = ctx.createGain();
        loopGain.gain.value = +loopVol.value;  // backing loop volume
        loopGain.connect(ctx.destination);

        // Load pad buffers
        await Promise.all(SAMPLES.map(async s => {
          const buf = await fetchDecode(SAMPLE_BASE + s.id + '.mp3');
          if (buf) padBuffers.set(s.id, buf);
        }));

        // Load backing loop (optional)
        try {
          const res = await fetch(DRUM_LOOP);
          if (res.ok) {
            const ab = await res.arrayBuffer();
            loopBuffer = await ctx.decodeAudioData(ab);
          }
        } catch {}

        setEnabled(true);
        mapKeys();
        status('ready ‚Äì press & hold pads or use keys 1-0');
      } catch (e) {
        console.error(e);
        status('error unlocking audio (see console)');
      }
    });

    playBtn.addEventListener('click', () => {
      if (!ctx || !loopBuffer) { status('loop file not found'); return; }
      if (loopSource) { status('already playing'); return; }
      loopSource = ctx.createBufferSource();
      loopSource.buffer = loopBuffer;
      loopSource.loop = true;
      loopSource.connect(loopGain);
      loopSource.start();
      status('loop: playing');
    });

    stopBtn.addEventListener('click', stopLoop);

    function stopLoop(){
      if (loopSource) {
        try { loopSource.stop(); } catch{}
        try { loopSource.disconnect(); } catch{}
        loopSource = null;
        status('loop: stopped');
      }
    }

    loopVol.addEventListener('input', () => {
      if (loopGain) loopGain.gain.value = +loopVol.value;
    });

    // ===== Helpers =====
    function status(t){ statusEl.textContent = t; }
    function setEnabled(on){
      playBtn.disabled = !on;
      stopBtn.disabled = !on;
      loopVol.disabled = !on;
      unlockBtn.disabled = on;
    }
    async function fetchDecode(url){
      try{
        const res = await fetch(url);
        if(!res.ok) return null;
        const ab = await res.arrayBuffer();
        return await (ctx || new (window.AudioContext||window.webkitAudioContext)()).decodeAudioData(ab);
      }catch{ return null; }
    }

    // ====== Press-and-hold smooth looping (crossfade retrigger) ======
    const holds = new WeakMap(); // btn -> { stop() }

    // Tunables
    const PAD_GAIN = 0.7;         // ~70% pad level (your request)
    const MIN_FADE = 0.02;        // 20ms fade edges
    const MAX_OVERLAP = 0.08;     // 80ms crossfade overlap
    const MAX_VOICES = 4;         // safety cap

    function startHoldLoop(id, btn, evt){
      if (!ctx) return;
      if (holds.get(btn)) return;

      const buf = padBuffers.get(id);
      if (!buf) { status(`missing: ${id}.mp3`); flash(btn); return; }

      if (evt && btn.setPointerCapture) {
        try { btn.setPointerCapture(evt.pointerId); } catch {}
      }
      btn.classList.add('playing');

      // Compute timings
      const period = Math.max(buf.duration, MIN_FADE * 3);
      const fade = Math.min(MIN_FADE, period * 0.2);
      const overlap = Math.min(MAX_OVERLAP, Math.max(fade * 1.5, period * 0.04));

      // Output gain node for this pad instance
      const out = ctx.createGain();
      out.gain.value = 0;
      out.connect(ctx.destination);

      const level = PAD_GAIN;

      // Voice scheduler with overlap-add crossfades
      let alive = true;
      let nextTime = ctx.currentTime + 0.002;
      const voices = new Set();
      let timer = null;

      function scheduleVoice(at){
        if (!alive) return;
        if (voices.size > MAX_VOICES) {
          const first = voices.values().next().value;
          try { first.src.stop(); } catch {}
          voices.delete(first);
        }
        const src = ctx.createBufferSource();
        src.buffer = buf;
        const g = ctx.createGain();
        g.gain.setValueAtTime(0, at);
        g.gain.linearRampToValueAtTime(level, at + fade);

        // fade out before overlap region
        const outStart = at + Math.max(0, period - overlap);
        g.gain.setValueAtTime(level, outStart);
        g.gain.linearRampToValueAtTime(0, outStart + fade);

        src.connect(g).connect(out);
        src.start(at);
        const stopAt = at + period + 0.25;
        src.stop(stopAt);

        const token = { src, g };
        voices.add(token);
        src.onended = () => voices.delete(token);
      }

      function tick(){
        if (!alive) return;
        const now = ctx.currentTime;
        while (nextTime < now + 0.25) {
          scheduleVoice(nextTime);
          nextTime += Math.max(0.01, period - overlap);
        }
        timer = setTimeout(tick, 25);
      }

      // smooth fade-in for pad output
      out.gain.cancelScheduledValues(ctx.currentTime);
      out.gain.setValueAtTime(0, ctx.currentTime);
      out.gain.linearRampToValueAtTime(1, ctx.currentTime + fade);

      // kick it off
      scheduleVoice(nextTime);
      nextTime += Math.max(0.01, period - overlap);
      tick();

      const stop = () => {
        if (!alive) return;
        alive = false;
        clearTimeout(timer);
        const t = ctx.currentTime;
        out.gain.cancelScheduledValues(t);
        out.gain.setValueAtTime(out.gain.value, t);
        out.gain.linearRampToValueAtTime(0, t + fade);
        setTimeout(() => { try { out.disconnect(); } catch {} }, (fade + 0.1) * 1000);
        voices.forEach(v => { try { v.src.stop(); } catch {} });
        voices.clear();
        btn.classList.remove('playing');
        holds.delete(btn);
      };

      holds.set(btn, { stop });
    }

    function stopHoldLoop(btn){
      const h = holds.get(btn);
      if (h) h.stop();
    }

    function flash(btn){
      if (!btn) return;
      btn.classList.add('playing');
      setTimeout(() => btn.classList.remove('playing'), 110);
    }

    // Keyboard start/stop
    window.addEventListener('keydown', (e) => {
      if (!ctx) return;
      let key = e.key;
      if (key === ')') key = '0';
      const btn = keyToBtn.get(key);
      if (!btn) return;
      if (e.repeat) return; // ignore key repeat
      startHoldLoop(btn.dataset.id, btn);
    });
    window.addEventListener('keyup', (e) => {
      let key = e.key;
      if (key === ')') key = '0';
      const btn = keyToBtn.get(key);
      if (!btn) return;
      stopHoldLoop(btn);
    });
  })();
  </script>
</body>
</html>
